{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./node_modules/@babel/runtime/regenerator/index.js","webpack:///./src/generate/general.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","runtime","undefined","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","makeInvokeMethod","tryCatch","fn","obj","arg","type","err","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","AsyncIterator","invoke","resolve","reject","record","result","Promise","__await","then","unwrapped","error","previousPromise","enqueue","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","done","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","flushMessage","a","messageFlag","setTimeout","tick","nonce","gen","instance","limit","performance","now","postMessage","body","occurrences","scheduleCount","schedules","addEventListener","e","data","index","args","input","hasOverlap","b","Array","j","day","end","start","segments","lookup","compatibility","Set","map","permute","_","sort","permutation","indexOf","seg","indices","options","o1","o2","i2","j2","add","dualId","buildHelper","stack","segment","id","isValid","compiled","has"],"mappings":"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","file":"21679e1b7ec970b27a30.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"b49d\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","module.exports = require(\"regenerator-runtime\");\n","if ('WorkerGlobalScope' in self) {\n    let messageFlag = false;\n    async function flushMessage() {\n        return new Promise(resolve => {\n            function next() {\n                if (messageFlag) {\n                    messageFlag = false;\n                    setTimeout(next, 1);\n                } else {\n                    resolve();\n                }\n            }\n\n            messageFlag = false;\n            setTimeout(next, 1);\n        });\n    }\n\n    const context = self as unknown as Worker;\n\n    let instance: Generator | null = null;\n\n    async function tick(nonce: any, gen: Generator) {\n        while (true) {\n            await flushMessage();\n\n            if (gen != instance) return;\n\n            let limit = performance.now() + 50;\n            let complete = gen.next(() => {\n                return limit < performance.now();\n            });\n\n            context.postMessage({\n                type: 'progress',\n                body: {\n                    nonce, complete,\n                    occurrences: gen.occurrences,\n                    scheduleCount: gen.schedules.length,\n                },\n            });\n\n            if (complete) {\n                break;\n            }\n        }\n    }\n\n    context.addEventListener('message', async e => {\n        messageFlag = true;\n        switch (e.data.type) {\n            case 'get': {\n                let index = e.data.body as number;\n\n                let result;\n                if (!instance || index < 0 || index >= instance.schedules.length)\n                    result = null;\n                else\n                    result = instance.schedules[index];\n\n                context.postMessage({\n                    type: 'get',\n                    body: result,\n                });\n                break;\n            }\n            case 'run': {\n                let args = e.data.body as {\n                    nonce: any,\n                    input: TimeBlock[][][],\n                };\n\n                instance = new Generator(args.input);\n                tick(args.nonce, instance);\n                break;\n            }\n        }\n    });\n}\n\nexport interface TimeBlock {\n    day: string;\n    start: number;\n    end: number;\n}\n\nexport function hasOverlap(a: TimeBlock | TimeBlock[], b: TimeBlock | TimeBlock[]) {\n    if (!(a instanceof Array)) a = [a];\n    if (!(b instanceof Array)) b = [b];\n\n    for (let i = 0; i < a.length; ++i) {\n        for (let j = 0; j < b.length; ++j) {\n            if (a[i].day == b[j].day &&\n                a[i].end > b[j].start &&\n                b[j].end > a[i].start) {\n                return true;\n            }\n        }\n    }\n}\n\nexport class Generator {\n    lookup: number[] = [];\n    compatibility = new Set<number>();\n\n    segments: { index: number, options: number[] }[] = [];\n\n    schedules: number[][] = [];\n    occurrences: number[][];\n\n    permutation: number[];\n\n    /**\n     * @param segments Each segment is an array of options. Each option is an array of time blocks that option occupies\n     */\n    constructor(segments: TimeBlock[][][]) {\n        this.occurrences = segments.map(s => s.map(() => 0));\n\n        let permute = segments.map((_, i) => i);\n        permute.sort((a, b) => segments[a].length - segments[b].length);\n\n        this.permutation = segments.map((_, i) => permute.indexOf(i));\n\n        segments.sort((a, b) => a.length - b.length);\n\n        for (let i = 0; i < segments.length; ++i) {\n            let seg = segments[i];\n\n            let indices = seg.map((_, j) => j);\n            let options = seg.map((_, j) => this.lookup.length + j);\n\n            this.lookup.push(...indices);\n            this.segments.push({ index: 0, options });\n        }\n\n        for (let i = 0; i < this.segments.length; ++i) {\n            for (let o1 of this.segments[i].options) {\n                for (let j = i + 1; j < this.segments.length; ++j) {\n                    for (let o2 of this.segments[j].options) {\n                        let i2 = this.lookup[o1];\n                        let j2 = this.lookup[o2];\n\n                        if (hasOverlap(segments[i][i2], segments[j][j2]))\n                            continue;\n\n                        this.compatibility.add(this.dualId(o1, o2));\n                    }\n                }\n            }\n        }\n    }\n\n    // returns true if completed\n    next(stop: () => boolean) {\n        if (this.segments.length == 0) return true;\n\n        return this.buildHelper([], 0, stop);\n    }\n\n    // returns true if completed\n    buildHelper(stack: number[], index: number, stop: () => boolean): boolean {\n        let segment = this.segments[index];\n\n        for (; segment.index < segment.options.length; ++segment.index) {\n            let id = segment.options[segment.index];\n            if (!this.isValid(stack, id)) {\n                if (stop())\n                    return false;\n                continue;\n            }\n\n            stack.push(id);\n            if (index + 1 == this.segments.length) {\n                let compiled = this.permutation.map(i => this.lookup[stack[i]]);\n\n                this.schedules.push(compiled);\n                for (let i = 0; i < compiled.length; ++i) {\n                    this.occurrences[i][compiled[i]]++;\n                }\n\n                if (stop()) {\n                    ++segment.index;\n                    return false;\n                }\n            } else if (!this.buildHelper(stack, index + 1, stop))\n                return false;\n            stack.pop();\n        }\n\n        segment.index = 0;\n        return true;\n    }\n\n    /**\n     * Checks if it is valid to add a section to a schedule\n     * @param index index of current segment\n     * @param section Potential addition\n     */\n    isValid(stack: number[], add: number) {\n        for (let id of stack) {\n            if (!this.compatibility.has(this.dualId(id, add))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private dualId(a: number, b: number) {\n        if (a < b)\n            return a * this.lookup.length + b;\n        return b * this.lookup.length + a;\n    }\n}\n"],"sourceRoot":""}